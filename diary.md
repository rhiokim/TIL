count(list) vs list.length
> 최근에 깊이 있게 시작하고 있지만 functionl progmaing 에 대한 이야기를 할때 이 두가지면 그 가치를 어느 정도 설명할 수 있다. 
> `count` 의 의미는 사전적으로 불변이고 어떤 input 에 대한 output 에 대한 메타포가 이미 내재되어 있다.
> `list` 는 상황에 따라 `list` 라고 했다가 `listArray` 라고 했다가 `collection` 이라고 했다가 `bookList` 라고 했다가 `filteredBookiList 라고 했다가 알고 봤더니 array 가 아니고 map, set 이였다가 `.length` 를 참조하려고 했던 본연의 목적은 '개수'
> '개수' 가 로직의 흐름을 만들기 때문이다.  _아 내공이 부족하다. 설명이 안된다._

38 + 2
> 38 살쯤 되었을때 인가? 그땐 뭐라도 할것 같았고 우당탕 즐기며 뒤도 안보고 달려왔던 시간들
> 그 시간들을 담보로 어떤 문제도 해결할 것만 같았다.
>
> 하지만 이 시기엔 다음 10년을 위한 정말 중요한 시기였다. 다음 세대로 접어드는 자동차 주행이라고 해야할까.
> 돌이켜 보면 물론 난 잘 준비하지 못했다. 해보지도 않았고 누군가의 했을 조언도 귀담아 듣지 않고 내멋대로 였을꺼니까.
> 
> 38 즈음엔 그동안에 하얀 도화지에 막연하게 그렸던 스케치를 좀더 알아 볼 수 있게
> 색깔을 입힐 수 있게 선명하게 그리는 2년을 보내면 좋을 것이다.
>
> 그건 그 다음 10년에 대한 꽤 중요한 기간이 될꺼니까.  <<와이프와 산책하던 어느날 밤>>

바둑
> 이세돌은 몇 수를 보고 바둑을 둬서 알파고를 이길 수 있었을까. 경험의 축적은 사람의 포퍼먼스를 향상 시키기 마련이다.
> 그 퍼포먼스는 온전히 그 사람의 것이고 상대해야할 대상과 1:1의 경쟁이라면 그 포퍼먼스는 위대하다.
>
> 하지만 상대할 대상이 1이고 그 1과 싸워야할 경험들이 n 이라면 그 n 은 어떻게 해야할까?
> 그리고 n 안에 포함된 유기체들은 협동을 통해 n + a 를 만들어 낼 수 있을까? 어려운 일이다.
>
> 1 을 해쳐나가기 위해서 2,3 수를 보는 사람과 10 수 이상을 보는 사람은 어떻게 협동할 수 있을까?
> 만약 서로 볼 수 있는 수가 다른 n 명의 사람이 협동을 한다면...

.filter(...)
> 우리는 평생 프로그래밍을 하면서 `filter` 함수에 넣는 함수 블럭을 몇가지 그리고 또 얼마나 비슷한 로직을
> 코딩하고 있을까? 요즘 함수 유틸리티를 만들면서 수도 없이 작성했던 filter 안의 함수 블럭,
> 저 안에는 생각보다 단순한 로직이 대부분이였던거 같다.  짝수, 홀수, null/undefined 를 걸러내거나, 정해진 정수가
> n 이상인지 이하인지, true 이거나 false 인것.
> 만약 이런한 함수 블럭을 초년생때부터 만들어 써왔다면 어땠을까? 지금에 와서야 느끼는...

first() vs coll[0] 의 차이
> `coll` 은 그냥 Array 타입의 데이터 스트력쳐이다. 그리고 그 array 의 0 번째 인덱스에 담긴값을 지시한다. 
> 이런 방식의 코드가 많아지면 로직의 흐름이 예외에 민감해지고 컨디션에 민감하게 되어 그에 대한 절차와 흐름을
> 정상적으로 유지하기 위해 많은 장치들이 요구된다.
> `first` 시멘틱하고 선언적이다. 입력값에 대한 첫번째 값을 기대할 수 있고 선언된 이름에서 흐름이 정의된다.

살아보니
> 잘하려면 정말 모든면에서 잘해야하고 그렇지 않으려면 살짝이 기울려 상대방에게 서로 기대보거나 기대어 주는 것이 중요하더라. 2020-09-15
