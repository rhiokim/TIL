바둑
> 이세돌은 몇 수를 보고 바둑을 둬서 알파고를 이길 수 있었을까. 경험의 축적은 사람의 포퍼먼스를 향상 시키기 마련이다.
> 그 퍼포먼스는 온전히 그 사람의 것이고 상대해야할 대상과 1:1의 경쟁이라면 그 포퍼먼스는 위대하다.
>
> 하지만 상대할 대상이 1이고 그 1과 싸워야할 경험들이 n 이라면 그 n 은 어떻게 해야할까?
> 그리고 n 안에 포함된 유기체들은 협동을 통해 n + a 를 만들어 낼 수 있을까? 어려운 일이다.
>
> 1 을 해쳐나가기 위해서 2,3 수를 보는 사람과 10 수 이상을 보는 사람은 어떻게 협동할 수 있을까?
> 만약 서로 볼 수 있는 수가 다른 n 명의 사람이 협동을 한다면...

.filter(...)
> 우리는 평생 프로그래밍을 하면서 `filter` 함수에 넣는 함수 블럭을 몇가지 그리고 또 얼마나 비슷한 로직을
> 코딩하고 있을까? 요즘 함수 유틸리티를 만들면서 수도 없이 작성했던 filter 안의 함수 블럭,
> 저 안에는 생각보다 단순한 로직이 대부분이였던거 같다.  짝수, 홀수, null/undefined 를 걸러내거나, 정해진 정수가
> n 이상인지 이하인지, true 이거나 false 인것.
> 만약 이런한 함수 블럭을 초년생때부터 만들어 써왔다면 어땠을까? 지금에 와서야 느끼는...

first() vs coll[0] 의 차이
> `coll` 은 그냥 Array 타입의 데이터 스트력쳐이다. 그리고 그 array 의 0 번째 인덱스에 담긴값을 지시한다. 
> 이런 방식의 코드가 많아지면 로직의 흐름이 예외에 민감해지고 컨디션에 민감하게 되어 그에 대한 절차와 흐름을
> 정상적으로 유지하기 위해 많은 장치들이 요구된다.
> `first` 시멘틱하고 선언적이다. 입력값에 대한 첫번째 값을 기대할 수 있고 선언된 이름에서 흐름이 정의된다.

살아보니
> 잘하려면 정말 모든면에서 잘해야하고 그렇지 않으려면 살짝이 기울려 상대방에게 서로 기대보거나 기대어 주는 것이 중요하더라. 2020-09-15
